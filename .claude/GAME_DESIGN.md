# 네트워크 슈퍼 마리오 - 게임 설계 문서

## 1. 기존 게임 구조 분석

### 핵심 클래스 구조

**GameEngine (manager/GameEngine.java)**
- 게임의 중심 엔진 - 메인 게임 루프 실행
- 60 FPS로 동작하는 게임 루프 (`run()` 메서드)
- 주요 기능:
  - `gameLoop()`: 업데이트 → 충돌 체크 → 카메라 업데이트
  - `updateLocations()`: 모든 게임 오브젝트 위치 업데이트
  - `checkCollisions()`: 충돌 감지
  - `receiveInput()`: 키보드 입력 처리
- 게임 상태: START_SCREEN, MAP_SELECTION, RUNNING, PAUSED, GAME_OVER, MISSION_PASSED

**Mario (model/hero/Mario.java)**
- 플레이어 캐릭터
- 상태: 위치(x, y), 속도(velX, velY), 점프/낙하 상태
- 속성: 생명(remainingLives), 코인(coins), 점수(points)
- 행동: jump(), move(), fire()

**MapManager (manager/MapManager.java)**
- 맵 데이터 관리
- 게임 오브젝트(적, 블록, 아이템) 관리
- 충돌 감지 및 처리
- 게임 오버/미션 완료 판정

**UIManager (view/UIManager.java)**
- Swing JPanel 기반 렌더링
- 화면: 시작 화면, 맵 선택, 게임 플레이, 일시정지, 게임 오버
- HUD: 생명, 코인, 점수, 시간 표시

**Camera (manager/Camera.java)**
- 마리오를 따라가는 카메라 시스템
- 화면 스크롤 처리

---

## 2. 멀티플레이어 게임 모드 설계

### 선택 가능한 게임 모드

#### 옵션 1: 협력 모드 (Co-op Mode) ⭐ 추천
**개념:**
- 2-4명의 플레이어가 같은 맵을 함께 플레이
- 공동 목표: 스테이지 클리어
- 공유 요소: 생명, 점수, 코인을 공유 OR 개별 관리

**장점:**
- 구현 난이도 중간
- 원작 게임 느낌 유지
- 협동 플레이 재미

**필요한 기능:**
- 여러 마리오 캐릭터 동시 렌더링
- 각 플레이어 위치 동기화
- 적/아이템 상태 동기화
- 카메라 처리 (선두 플레이어 따라가기 OR 전체 플레이어 평균)

#### 옵션 2: 경쟁 모드 (Race Mode)
**개념:**
- 누가 먼저 깃발에 도착하는지 경쟁
- 개별 점수/생명 관리
- 순위 시스템

**장점:**
- 경쟁적 재미
- 단순한 승패 판정

**단점:**
- 카메라 처리 복잡 (각 플레이어마다 다른 위치)
- 화면 분할 필요할 수도 있음

#### 옵션 3: 배틀 모드
**개념:**
- PvP 전투
- 서로 공격 가능

**단점:**
- 원작과 너무 다름
- 구현 복잡도 높음
- 시간 부족

### 🎯 최종 선택: **협력 모드 (Co-op Mode)**

**이유:**
1. 구현 난이도가 적절함
2. 원작 게임플레이 유지 가능
3. 네트워크 기능 충분히 시연 가능
4. 마감 시간 내 완성 가능성 높음

---

## 3. 협력 모드 상세 설계

### 게임 플레이 규칙

**플레이어 수:** 2명 (확장 가능하게 설계하되 우선 2명)

**공유 요소:**
- ❌ 생명: 개별 관리 (각자 3개)
- ✅ 맵 상태: 블록, 적, 아이템은 공유
- ✅ 시간 제한: 공유
- ❓ 점수/코인: 개별 OR 공유 (나중에 결정)

**게임 진행:**
1. 호스트가 방 생성 → 게스트가 참가
2. 호스트가 맵 선택
3. 양쪽 준비 완료 시 게임 시작
4. 동시에 플레이
5. 조건 달성 시 종료
   - 승리: 한 명이라도 깃발 도달
   - 패배: 모든 플레이어 생명 0 OR 시간 초과

**카메라 처리:**
- 앞서가는 플레이어를 따라감
- 뒤처진 플레이어는 화면 밖으로 나가면 앞 플레이어 위치로 순간이동

**충돌 처리:**
- 플레이어끼리는 통과 가능 (충돌 무시)
- 적/블록/아이템은 양쪽 모두 상호작용 가능
- 아이템은 먼저 먹은 사람이 획득

---

## 4. 네트워크 아키텍처 설계

### 클라이언트-서버 모델 ⭐ 선택

**구조:**
```
서버 (호스트)              클라이언트 (게스트)
├─ GameEngine            ├─ NetworkClient
├─ MapManager            ├─ GameRenderer
├─ 게임 로직 실행          ├─ 입력 전송
├─ 충돌 감지              ├─ 상태 수신
├─ 상태 브로드캐스트       └─ 화면 렌더링
└─ NetworkServer
```

**역할 분담:**

**서버 (호스트 플레이어)**
- 권한 있는 게임 상태 관리
- 게임 로직 실행 (물리, 충돌, 적 AI)
- 모든 클라이언트 입력 수신
- 게임 상태 브로드캐스팅
- 자신도 플레이어로 참여

**클라이언트 (게스트 플레이어)**
- 입력만 서버로 전송
- 서버로부터 게임 상태 수신
- 렌더링만 담당
- 로컬에서 부드러운 움직임을 위한 예측 (선택사항)

### 통신 프로토콜

**전송 방식: TCP** (수업 자료 기반)
- 이유: 신뢰성 필요, UDP보다 구현 간단
- DataInputStream/DataOutputStream 사용

**메시지 타입:**

```java
// 클라이언트 → 서버
1. CONNECT(playerName)           // 연결 요청
2. INPUT(keyCode, pressed)       // 입력 (키 누름/뗌)
3. READY()                       // 준비 완료
4. DISCONNECT()                  // 연결 해제

// 서버 → 클라이언트
1. CONNECTED(playerId)           // 연결 승인
2. PLAYER_JOINED(playerId, name) // 다른 플레이어 참가
3. GAME_STATE(...)               // 게임 상태 전체 (주기적)
4. GAME_START()                  // 게임 시작
5. GAME_OVER(reason)             // 게임 종료
6. PLAYER_LEFT(playerId)         // 플레이어 퇴장
```

**게임 상태 동기화 데이터:**
```java
GAME_STATE {
    // 플레이어 1
    int player1X
    int player1Y
    int player1VelX
    int player1VelY
    boolean player1Jumping
    boolean player1ToRight
    int player1Lives
    int player1Coins
    int player1Points

    // 플레이어 2
    int player2X
    int player2Y
    ... (동일)

    // 적들 (동적 개수)
    int enemyCount
    for each enemy:
        int enemyX
        int enemyY
        boolean alive

    // 아이템들
    int itemCount
    for each item:
        int itemX
        int itemY
        boolean collected

    // 파이어볼들
    int fireballCount
    for each fireball:
        int fireballX
        int fireballY
        boolean active

    // 게임 정보
    int remainingTime
    double cameraX
}
```

### 동기화 전략

**업데이트 주기:**
- 서버 게임 루프: 60 FPS (기존 유지)
- 네트워크 전송: 20 Hz (초당 20번) - 성능과 부드러움의 균형
- 입력 전송: 변화 발생 시마다 (키 누름/뗌 순간만)

**최적화:**
- 변경된 데이터만 전송 (선택사항, 시간 있으면)
- 보간(Interpolation)으로 부드러운 움직임 (선택사항)

---

## 5. 구현 우선순위

### Phase 1: 기본 네트워크 연결 (필수)
- [ ] ServerSocket 구현 (port: 25565)
- [ ] Socket 클라이언트 구현
- [ ] 연결/연결 해제 처리
- [ ] 간단한 메시지 송수신 테스트

### Phase 2: 프로토콜 구현 (필수)
- [ ] 메시지 타입 enum 정의
- [ ] DataInputStream/DataOutputStream 기반 프로토콜
- [ ] 메시지 송수신 클래스 구현

### Phase 3: 게임 상태 동기화 (필수)
- [ ] 게임 상태 직렬화/역직렬화
- [ ] 서버: 게임 상태 수집 → 전송
- [ ] 클라이언트: 게임 상태 수신 → 적용
- [ ] 두 플레이어 위치 동기화

### Phase 4: 멀티플레이어 게임 로직 (필수)
- [ ] 두 번째 Mario 객체 렌더링
- [ ] 각 플레이어 입력 분리 처리
- [ ] 적/아이템 상태 동기화
- [ ] 카메라 로직 수정

### Phase 5: UI 개선 (선택)
- [ ] 로비 화면 (대기실)
- [ ] 플레이어 이름 표시
- [ ] 연결 상태 표시
- [ ] 채팅 (시간 있으면)

### Phase 6: 테스트 및 안정화 (필수)
- [ ] localhost 테스트
- [ ] 서로 다른 PC 테스트
- [ ] 버그 수정
- [ ] 에러 처리

---

## 6. 기술 스택 정리

### 네트워킹
- **프로토콜:** TCP/IP
- **클래스:** `ServerSocket`, `Socket`
- **스트림:** `DataInputStream`, `DataOutputStream`
- **스레드:** 수신 스레드 (Runnable 구현)

### 게임 엔진
- **기존 코드:** GameEngine, MapManager, Mario
- **수정 필요:** 네트워크 레이어 추가, 멀티플레이어 지원

### UI
- **기존:** Swing (JFrame, JPanel)
- **추가:** 네트워크 설정 화면, 로비 화면

---

## 7. 파일 구조 계획

```
src/
├── manager/           # 기존 게임 관리자
│   ├── GameEngine.java      (수정 필요)
│   └── ...
├── model/            # 기존 게임 오브젝트
│   └── ...
├── view/             # 기존 UI
│   └── ...
└── network/          # 🆕 새로 추가
    ├── NetworkManager.java       # 네트워크 총괄
    ├── server/
    │   ├── GameServer.java       # 서버 메인
    │   └── ClientHandler.java    # 각 클라이언트 처리
    ├── client/
    │   ├── GameClient.java       # 클라이언트 메인
    │   └── ServerListener.java   # 서버 메시지 수신
    └── protocol/
        ├── Message.java          # 메시지 기본 클래스
        ├── MessageType.java      # 메시지 타입 enum
        └── GameStatePacket.java  # 게임 상태 패킷
```

---

## 8. 시연 시나리오

### 시연 내용 (5-10분 동영상)
1. **소개 (1분)**
   - 프로젝트 개요 설명
   - 원본 게임과 차이점

2. **네트워크 연결 (1분)**
   - 서버 시작
   - 클라이언트 접속
   - 로비 화면

3. **게임 플레이 (3-5분)**
   - 두 플레이어 동시 조작
   - 협력 플레이 시연
   - 적 처치, 아이템 획득
   - 승리/패배 조건 시연

4. **코드 리뷰 (2-3분)**
   - 네트워크 코드 핵심 부분 설명
   - 게임 상태 동기화 로직
   - 프로토콜 구현

---

## 9. 예상 문제와 해결 방안

### 문제 1: 네트워크 지연
**해결:**
- 우선은 localhost/LAN 환경에서만 테스트
- 시간 있으면 클라이언트 예측 구현

### 문제 2: 동기화 불일치
**해결:**
- 서버 권한 모델 - 서버 상태가 항상 정답
- 클라이언트는 서버 상태를 무조건 따름

### 문제 3: 연결 끊김 처리
**해결:**
- 연결 끊김 감지 → 상대방 화면에 표시
- 재연결 기능은 시간 부족 시 생략

### 문제 4: 화면 크기 제약
**해결:**
- 두 플레이어가 너무 멀어지면 뒤처진 플레이어 순간이동
- OR 카메라를 두 플레이어 중간에 위치

---

## 10. 마감 시간 관리

**현재 시각:** 2024-12-14 (마감 당일!)
**남은 시간:** ~12시간

**시간 배분:**
- Phase 1 (네트워크 연결): 2시간
- Phase 2 (프로토콜): 2시간
- Phase 3 (게임 상태 동기화): 3시간
- Phase 4 (멀티플레이어 로직): 3시간
- 테스트 및 버그 수정: 1시간
- 시연 영상 녹화: 30분
- PPT 작성: 30분

**🚨 중요: 완벽보다는 작동하는 최소 기능에 집중!**

---

## 11. 최종 체크리스트

### 필수 기능
- [ ] 서버-클라이언트 연결
- [ ] 두 플레이어 화면에 표시
- [ ] 각 플레이어 입력 처리
- [ ] 플레이어 위치 동기화
- [ ] 적/아이템 상태 동기화
- [ ] 게임 시작/종료 처리

### 제출물
- [ ] 시연 동영상 (5-10분)
- [ ] 최종 보고서 PPT
- [ ] 소스코드 (Eclipse 프로젝트)
- [ ] 원본 소스코드 + 실행 영상

---

**다음 단계:** 네트워크 패키지 구조 생성 및 기본 서버-클라이언트 구현 시작!
